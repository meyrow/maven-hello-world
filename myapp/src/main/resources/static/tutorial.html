<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitOps Platform Tutorial - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .profile-image {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .profile-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .header-text {
            flex: 1;
        }

        .header h1 {
            color: #2d3748;
            margin-bottom: 5px;
            font-size: 32px;
        }

        .header p {
            color: #718096;
            font-size: 16px;
        }

        .header-links {
            text-align: center;
            margin-top: 20px;
        }

        .back-link {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            margin: 5px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .back-link:hover {
            background: #5a67d8;
        }

        .content {
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        h2 {
            color: #2d3748;
            margin-top: 40px;
            margin-bottom: 15px;
            font-size: 28px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h2:first-of-type {
            margin-top: 0;
        }

        h3 {
            color: #4a5568;
            margin-top: 25px;
            margin-bottom: 12px;
            font-size: 22px;
        }

        h4 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 18px;
        }

        p {
            color: #4a5568;
            margin-bottom: 15px;
        }

        .step {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 15px 0;
            white-space: pre;
        }

        .highlight {
            background: #fef5e7;
            padding: 15px;
            border-left: 4px solid #f39c12;
            border-radius: 5px;
            margin: 15px 0;
        }

        .success {
            background: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            border-radius: 5px;
            margin: 15px 0;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
            color: #4a5568;
        }

        li {
            margin-bottom: 8px;
        }

        .tech-stack {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .tech-item {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            color: #2d3748;
        }

        .diagram-link {
            background: #667eea;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            text-decoration: none;
            display: inline-block;
            margin: 20px 10px 20px 0;
            font-weight: 600;
            font-size: 16px;
            transition: background 0.3s;
        }

        .diagram-link:hover {
            background: #5a67d8;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: #f7fafc;
        }

        a {
            color: #667eea;
            text-decoration: none;
        }

        a:hover {
            color: #5a67d8;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div class="header-content">
            <div class="profile-image">
                <img
                        src="https://lh3.googleusercontent.com/a/ACg8ocLrnyOd_xegnVjfkJFaOu0WsYNdWopOJv2qeK4BTMvoEPNe7Sn8=s340-p-k-no"
                        alt="Ilan Melamud"
                        onerror="this.parentElement.innerHTML='IL'; this.parentElement.style.display='flex'; this.parentElement.style.alignItems='center'; this.parentElement.style.justifyContent='center'; this.parentElement.style.fontSize='24px'; this.parentElement.style.fontWeight='bold'; this.parentElement.style.color='white'; this.parentElement.style.background='linear-gradient(135deg, #667eea 0%, #764ba2 100%)'"
                />
            </div>
            <div class="header-text">
                <h1>üöÄ Cloud-Native GitOps Platform</h1>
                <p>Complete Tutorial & Architecture Guide by Ilan Melamud</p>
            </div>
        </div>
        <div class="header-links">
            <a href="/" class="back-link">üè† Dashboard</a>
            <a href="/flow-diagram.html" class="back-link">üìä Flow Diagram</a>
        </div>
    </div>

    <div class="content">
        <h2>üìã Table of Contents</h2>
        <ol>
            <li><a href="#overview">Platform Overview</a></li>
            <li><a href="#architecture">System Architecture</a></li>
            <li><a href="#tech-stack">Technology Stack</a></li>
            <li><a href="#versioning">Version Management Strategy</a></li>
            <li><a href="#dockerfile">Dockerfile Multi-Stage Build</a></li>
            <li><a href="#cloud-choice">Why Google Cloud & Multi-Node</a></li>
            <li><a href="#setup">Complete Setup Guide</a></li>
            <li><a href="#deployment">Deployment Pipeline</a></li>
            <li><a href="#jenkins-comparison">Jenkins vs GitOps</a></li>
            <li><a href="#gitops">GitOps Workflow</a></li>
            <li><a href="#argocd-gitops">Why Direct Edits Are Ignored</a></li>
            <li><a href="#monitoring">Monitoring & Operations</a></li>
            <li><a href="#troubleshooting">Troubleshooting</a></li>
        </ol>

        <h2 id="overview">üéØ Platform Overview</h2>
        <p>
            This is a production-ready, cloud-native application demonstrating modern DevOps practices,
            GitOps principles, and container orchestration. The platform showcases automated CI/CD pipelines,
            declarative deployments, and self-healing infrastructure.
        </p>

        <div class="highlight">
            <strong>üéØ Key Objectives:</strong>
            <ul>
                <li>Zero-downtime deployments with rolling updates</li>
                <li>Automated CI/CD pipeline with version control</li>
                <li>GitOps-based declarative deployments</li>
                <li>Auto-scaling based on resource utilization</li>
                <li>Self-healing infrastructure with health monitoring</li>
            </ul>
        </div>

        <h2 id="architecture">üèóÔ∏è System Architecture</h2>

        <h3>Architecture Components</h3>
        <div class="step">
            <h4>1. Development Layer</h4>
            <ul>
                <li><strong>Spring Boot Application:</strong> RESTful microservice with health endpoints</li>
                <li><strong>React Dashboard:</strong> Real-time monitoring interface</li>
                <li><strong>Maven Build:</strong> Dependency management and packaging</li>
            </ul>
        </div>

        <div class="step">
            <h4>2. CI/CD Layer</h4>
            <ul>
                <li><strong>GitHub Actions:</strong> Automated build, test, and deployment</li>
                <li><strong>Docker Build:</strong> Multi-stage containerization</li>
                <li><strong>Version Tagging:</strong> Git SHA-based unique tags</li>
            </ul>
        </div>

        <div class="step">
            <h4>3. Artifact Storage</h4>
            <ul>
                <li><strong>Docker Hub:</strong> Container image registry</li>
                <li><strong>GitHub:</strong> Helm chart repository</li>
            </ul>
        </div>

        <div class="step">
            <h4>4. GitOps Layer</h4>
            <ul>
                <li><strong>ArgoCD:</strong> Continuous delivery and sync engine</li>
                <li><strong>Helm Charts:</strong> Kubernetes manifest templates</li>
                <li><strong>Git Repository:</strong> Single source of truth</li>
            </ul>
        </div>

        <div class="step">
            <h4>5. Infrastructure Layer</h4>
            <ul>
                <li><strong>Google Kubernetes Engine:</strong> Managed Kubernetes cluster</li>
                <li><strong>Load Balancer:</strong> External traffic routing</li>
                <li><strong>Auto-Scaling:</strong> HPA based on CPU/memory</li>
            </ul>
        </div>

        <h2 id="tech-stack">üíª Technology Stack</h2>

        <div class="tech-stack">
            <div class="tech-item">‚òï Java 17 LTS</div>
            <div class="tech-item">üçÉ Spring Boot 2.7</div>
            <div class="tech-item">‚öõÔ∏è React 18</div>
            <div class="tech-item">üî® Maven 3.9</div>
            <div class="tech-item">üê≥ Docker</div>
            <div class="tech-item">‚ò∏Ô∏è Kubernetes</div>
            <div class="tech-item">‚éà Helm 3</div>
            <div class="tech-item">üîÑ ArgoCD</div>
            <div class="tech-item">‚ö° GitHub Actions</div>
            <div class="tech-item">‚òÅÔ∏è Google Cloud</div>
            <div class="tech-item">üêã Docker Hub</div>
            <div class="tech-item">üìä Grafana</div>
        </div>

        <h2 id="versioning">üè∑Ô∏è Version Management Strategy</h2>

        <h3>Why Version Management Matters</h3>
        <p>
            Proper version management is critical for production deployments. Without a robust versioning strategy,
            you face deployment conflicts, inability to rollback, lack of traceability, and compliance issues.
        </p>

        <div class="highlight">
            <strong>‚ö†Ô∏è Problems Without Proper Versioning:</strong>
            <ul>
                <li>‚ùå Cannot identify which code is running in production</li>
                <li>‚ùå Cannot rollback to previous working versions</li>
                <li>‚ùå Multiple deployments overwrite each other</li>
                <li>‚ùå No audit trail of what changed and when</li>
                <li>‚ùå Kubernetes won't pull "updated" images with same tag</li>
            </ul>
        </div>

        <h3>Our Versioning Strategy: Base Version + Git SHA</h3>

        <h4>1. Base Version in pom.xml (Single Source of Truth)</h4>
        <p>
            The <code>pom.xml</code> file contains the base semantic version:
        </p>
        <div class="code-block">&lt;project&gt;
            &lt;groupId&gt;com.myapp&lt;/groupId&gt;
            &lt;artifactId&gt;maven-hello-world&lt;/artifactId&gt;
            &lt;version&gt;1.0.1&lt;/version&gt;  ‚Üê Single source of truth
            &lt;/project&gt;</div>

        <p><strong>Why pom.xml?</strong></p>
        <ul>
            <li>‚úÖ Maven naturally uses it for artifact naming</li>
            <li>‚úÖ Already part of Java/Spring Boot ecosystem</li>
            <li>‚úÖ Integrated with build tools and IDEs</li>
            <li>‚úÖ Can be extracted programmatically</li>
            <li>‚úÖ Developers already familiar with it</li>
        </ul>

        <div class="step">
            <h4>2. Maven Resource Filtering (Inject Version at Build Time)</h4>
            <p>We use Maven resource filtering to inject the version into the application:</p>
            <div class="code-block"># pom.xml
                &lt;build&gt;
                &lt;resources&gt;
                &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;  ‚Üê Enable filtering
                &lt;/resource&gt;
                &lt;/resources&gt;
                &lt;/build&gt;

                # application.properties
                app.version=@project.version@  ‚Üê Placeholder

                # After build:
                app.version=1.0.1  ‚Üê Injected by Maven</div>

            <p><strong>Benefits:</strong></p>
            <ul>
                <li>‚úÖ No manual version synchronization needed</li>
                <li>‚úÖ Application automatically knows its version</li>
                <li>‚úÖ Displayed in /health endpoint and dashboard</li>
            </ul>
        </div>

        <div class="step">
            <h4>3. Git SHA (Unique Deployment Identifier)</h4>
            <p>During CI/CD, we append the Git commit SHA to create unique tags:</p>
            <div class="code-block"># GitHub Actions workflow
                BASE_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
                GIT_SHA=$(git rev-parse --short HEAD)
                VERSION="${BASE_VERSION}-${GIT_SHA}"

                # Result:
                BASE_VERSION = 1.0.1
                GIT_SHA = abc123f
                VERSION = 1.0.1-abc123f  ‚Üê Final Docker tag</div>

            <p><strong>Why Add Git SHA?</strong></p>
            <ul>
                <li>‚úÖ <strong>Uniqueness:</strong> Every commit gets a unique tag</li>
                <li>‚úÖ <strong>Traceability:</strong> Can trace back to exact code</li>
                <li>‚úÖ <strong>Auto-deployment:</strong> ArgoCD detects new versions automatically</li>
                <li>‚úÖ <strong>No manual intervention:</strong> Versions increment automatically</li>
                <li>‚úÖ <strong>Rollback capability:</strong> Can identify and revert to any version</li>
            </ul>
        </div>

        <h3>Complete Version Flow</h3>
        <div class="code-block">Developer Updates Code
            ‚Üì
            Git Commit: abc123f
            ‚Üì
            GitHub Actions Triggered
            ‚Üì
            Extract from pom.xml: version = 1.0.1
            Get Git SHA: sha = abc123f
            Combine: version = 1.0.1-abc123f
            ‚Üì
            Build Docker Image
            ‚Üì
            Create 3 Tags:
            - ilanm/maven-hello-world:1.0.1-abc123f  ‚Üê Unique (used by ArgoCD)
            - ilanm/maven-hello-world:1.0.1          ‚Üê Stable base version
            - ilanm/maven-hello-world:latest         ‚Üê Always most recent
            ‚Üì
            Push to Docker Hub
            ‚Üì
            Update helm-chart/values.yaml:
            image:
            tag: "1.0.1-abc123f"
            ‚Üì
            Commit to Git
            ‚Üì
            ArgoCD Detects Change
            ‚Üì
            Kubernetes Pulls: ilanm/maven-hello-world:1.0.1-abc123f
            ‚Üì
            New Version Running in Production ‚úÖ</div>

        <h3>Version Comparison: Different Strategies</h3>

        <table>
            <tr>
                <th>Strategy</th>
                <th>Example</th>
                <th>Uniqueness</th>
                <th>Traceability</th>
                <th>Auto-Deploy</th>
            </tr>
            <tr>
                <td>Static version</td>
                <td>1.0.0</td>
                <td>‚ùå No</td>
                <td>‚ùå No</td>
                <td>‚ùå No</td>
            </tr>
            <tr>
                <td>Manual increment</td>
                <td>1.0.0, 1.0.1, 1.0.2</td>
                <td>‚ö†Ô∏è If remembered</td>
                <td>‚ö†Ô∏è Partial</td>
                <td>‚ùå Manual</td>
            </tr>
            <tr>
                <td>Timestamp</td>
                <td>1.0.0-20251229</td>
                <td>‚úÖ Yes</td>
                <td>‚ö†Ô∏è Time only</td>
                <td>‚úÖ Yes</td>
            </tr>
            <tr>
                <td>Build number</td>
                <td>1.0.0-build-42</td>
                <td>‚úÖ Yes</td>
                <td>‚ö†Ô∏è No code link</td>
                <td>‚úÖ Yes</td>
            </tr>
            <tr>
                <td><strong>Base + Git SHA</strong></td>
                <td><strong>1.0.1-abc123f</strong></td>
                <td><strong>‚úÖ Yes</strong></td>
                <td><strong>‚úÖ Full</strong></td>
                <td><strong>‚úÖ Yes</strong></td>
            </tr>
        </table>

        <h3>Real-World Example: Troubleshooting Production Issue</h3>

        <div class="step">
            <p><strong>Scenario:</strong> Bug discovered in production</p>
            <div class="code-block"># Check running version
                kubectl get pods -o jsonpath='{.items[0].spec.containers[0].image}'
                # Output: ilanm/maven-hello-world:1.0.1-abc123f

                # Find exact code
                git checkout abc123f
                # Now you have EXACT code running in production

                # Check what changed
                git log abc123f -5 --oneline
                # See last 5 commits before this version

                # Identify problematic commit
                git diff def456a..abc123f
                # See what changed between versions

                # Rollback (revert to previous version)
                # Option 1: Git revert
                git revert HEAD
                git push

                # Option 2: Update Helm chart to previous tag
                # values.yaml: tag: "1.0.1-def456a"
                git commit -am "rollback: revert to 1.0.1-def456a"
                git push

                # ArgoCD auto-deploys previous working version ‚úÖ</div>
        </div>

        <h3>Kubernetes Image Pull Behavior</h3>

        <div class="highlight">
            <strong>‚ö†Ô∏è Critical Kubernetes Behavior:</strong>
            <p>Kubernetes has an <code>imagePullPolicy</code> that affects when images are pulled:</p>
        </div>

        <div class="code-block"># If tag is "latest" or not specified:
            imagePullPolicy: Always  # Always pulls from registry

            # If tag is specific (e.g., "1.0.1"):
            imagePullPolicy: IfNotPresent  # Only pulls if not cached

            # Problem with reusing tags:
            Docker build ‚Üí tag: "1.0.1" ‚Üí push to registry
            Kubernetes sees tag "1.0.1" already cached
            Kubernetes does NOT pull updated image ‚ùå
            Old version keeps running!

            # Solution with Git SHA:
            Docker build ‚Üí tag: "1.0.1-abc123f" ‚Üí push
            Kubernetes sees NEW tag never seen before
            Kubernetes MUST pull new image ‚úÖ
            New version deploys correctly!</div>

        <h3>Semantic Versioning in Base Version</h3>

        <p>The base version in pom.xml follows semantic versioning:</p>
        <div class="code-block">MAJOR.MINOR.PATCH

            1.0.0 ‚Üí 1.0.1  (Patch: bug fix, backwards compatible)
            1.0.1 ‚Üí 1.1.0  (Minor: new feature, backwards compatible)
            1.1.0 ‚Üí 2.0.0  (Major: breaking changes)

            Examples:
            - 1.0.0-abc123f  (First release, commit abc123f)
            - 1.0.1-def456a  (Bug fix, commit def456a)
            - 1.1.0-ghi789b  (New feature, commit ghi789b)
            - 2.0.0-jkl012c  (Breaking change, commit jkl012c)</div>

        <div class="success">
            <strong>üéØ Key Takeaway:</strong> Base version in pom.xml provides human-readable semantic meaning,
            while Git SHA provides machine-readable uniqueness and traceability. Together, they create the
            perfect versioning strategy for cloud-native applications.
        </div>

        <h2 id="dockerfile">üê≥ Dockerfile Multi-Stage Build Strategy</h2>

        <h3>Why Multi-Stage Builds?</h3>
        <p>
            Our Dockerfile uses a multi-stage build strategy to create secure, minimal, production-ready container images.
            This approach dramatically reduces image size, attack surface, and security vulnerabilities.
        </p>

        <h3>Our Dockerfile Structure</h3>
        <div class="code-block"># Stage 1: Build Stage (Builder)
            FROM maven:3.9-eclipse-temurin-17 AS builder
            WORKDIR /app
            COPY pom.xml .
            COPY src ./src
            RUN mvn clean package -Dmaven.test.skip=true

            # Stage 2: Runtime Stage (Final Image)
            FROM eclipse-temurin:17-jre
            WORKDIR /app

            # Create non-root user
            RUN groupadd -r appuser && useradd -r -g appuser appuser
            RUN chown -R appuser:appuser /app

            # Copy only the JAR from builder stage
            COPY --from=builder /app/target/*.jar app.jar

            # Switch to non-root user
            USER appuser

            EXPOSE 8080
            HEALTHCHECK --interval=30s --timeout=3s \
            CMD curl -f http://localhost:8080/health || exit 1

            ENTRYPOINT ["java", "-jar", "app.jar"]</div>

        <h3>Security Benefits</h3>
        <div class="step">
            <h4>1. Non-Root User Execution</h4>
            <p><strong>Problem:</strong> Running as root is a major security risk. If container is compromised, attacker has root access.</p>
            <p><strong>Solution:</strong> We create and use a dedicated non-root user <code>appuser</code> (UID 1001).</p>
            <div class="code-block"># Create user and group
                RUN groupadd -r appuser && useradd -r -g appuser appuser

                # Change ownership
                RUN chown -R appuser:appuser /app

                # Switch user
                USER appuser</div>
            <p><strong>Result:</strong> ‚úÖ Application runs with minimal privileges</p>
        </div>

        <div class="step">
            <h4>2. Minimal Base Image</h4>
            <p><strong>Problem:</strong> Full JDK images include compilers, debuggers, and unnecessary tools (755MB+).</p>
            <p><strong>Solution:</strong> Use JRE-only runtime image that contains only what's needed to run Java applications.</p>
            <div class="code-block"># Builder stage: maven:3.9-eclipse-temurin-17 (~755MB)
                # Runtime stage: eclipse-temurin:17-jre (~328MB)</div>
            <p><strong>Result:</strong> ‚úÖ 57% smaller image, fewer attack vectors</p>
        </div>

        <div class="step">
            <h4>3. No Build Tools in Production</h4>
            <p><strong>Problem:</strong> Maven, compilers, and build tools in production images create security risks.</p>
            <p><strong>Solution:</strong> Build tools only exist in builder stage, discarded in final image.</p>
            <p><strong>Result:</strong> ‚úÖ No compilers or build tools that could be exploited</p>
        </div>

        <div class="step">
            <h4>4. Reduced Attack Surface</h4>
            <p><strong>Problem:</strong> Unnecessary packages increase CVE exposure.</p>
            <p><strong>Solution:</strong> Only include JRE and application JAR in final image.</p>
            <div class="code-block"># What's NOT in our production image:
                ‚ùå Maven
                ‚ùå Git
                ‚ùå Build tools
                ‚ùå Development libraries
                ‚ùå Shell utilities
                ‚ùå Package managers

                # What IS in our production image:
                ‚úÖ JRE 17
                ‚úÖ Application JAR
                ‚úÖ Minimal OS base</div>
            <p><strong>Result:</strong> ‚úÖ Minimal CVE exposure</p>
        </div>

        <h3>Image Size Comparison</h3>
        <table>
            <tr>
                <th>Approach</th>
                <th>Image Size</th>
                <th>Security</th>
                <th>Production Ready</th>
            </tr>
            <tr>
                <td>Single-stage with JDK</td>
                <td>755 MB</td>
                <td>‚ùå High risk</td>
                <td>‚ùå No</td>
            </tr>
            <tr>
                <td>Single-stage with JRE</td>
                <td>450 MB</td>
                <td>‚ö†Ô∏è Medium risk</td>
                <td>‚ö†Ô∏è Partial</td>
            </tr>
            <tr>
                <td><strong>Multi-stage with JRE + non-root</strong></td>
                <td><strong>328 MB</strong></td>
                <td><strong>‚úÖ Low risk</strong></td>
                <td><strong>‚úÖ Yes</strong></td>
            </tr>
        </table>

        <div class="success">
            <strong>üîí Security Summary:</strong> Our multi-stage build creates a production-hardened image
            that's 57% smaller, runs as non-root, contains no build tools, and minimizes attack surface.
        </div>

        <h2 id="cloud-choice">‚òÅÔ∏è Why Google Cloud Platform & Multi-Node Architecture</h2>

        <h3>Why We Chose Google Cloud</h3>

        <div class="step">
            <h4>1. GKE Autopilot & Standard Options</h4>
            <p>
                GCP offers both Autopilot (fully managed) and Standard (configurable) GKE clusters.
                We chose <strong>Standard</strong> for fine-grained control over node configuration and costs.
            </p>
            <table style="margin-top: 15px;">
                <tr>
                    <th>Feature</th>
                    <th>Autopilot</th>
                    <th>Standard (Our Choice)</th>
                </tr>
                <tr>
                    <td>Node Management</td>
                    <td>Fully managed</td>
                    <td>User controlled</td>
                </tr>
                <tr>
                    <td>Pod Resources</td>
                    <td>Auto-provisioned</td>
                    <td>Fixed node pools</td>
                </tr>
                <tr>
                    <td>Cost</td>
                    <td>Pay per pod</td>
                    <td>Pay per node (predictable)</td>
                </tr>
                <tr>
                    <td>Control</td>
                    <td>Limited</td>
                    <td>Full control</td>
                </tr>
            </table>
        </div>

        <div class="step">
            <h4>2. Free Trial Credits</h4>
            <p>
                ‚úÖ $300 (‚Ç™983) in free credits for 90 days<br>
                ‚úÖ No automatic charges after trial<br>
                ‚úÖ Perfect for demos and POCs
            </p>
        </div>

        <div class="step">
            <h4>3. Kubernetes-Native</h4>
            <p>
                GKE is built by Google, the creators of Kubernetes. It provides:
            </p>
            <ul>
                <li>Latest Kubernetes versions immediately</li>
                <li>Best-in-class integration</li>
                <li>Excellent documentation</li>
                <li>Native GCP service integration</li>
            </ul>
        </div>

        <h3>Why Multi-Node Architecture (2 Nodes)?</h3>

        <div class="step">
            <h4>1. High Availability</h4>
            <p><strong>Single Node:</strong> If node fails ‚Üí entire application down ‚ùå</p>
            <p><strong>Multi-Node:</strong> If one node fails ‚Üí app continues running on other node ‚úÖ</p>
            <div class="code-block"># Our setup:
                Node 1: gke-maven-hello-world-cl-default-pool-...-0j8r
                Node 2: gke-maven-hello-world-cl-default-pool-...-24jx

                # Pod distribution:
                Pod 1 ‚Üí Node 1
                Pod 2 ‚Üí Node 2

                # If Node 1 fails:
                Pod 1 ‚Üí Rescheduled to Node 2
                Pod 2 ‚Üí Still running
                Result: Zero downtime! ‚úÖ</div>
        </div>

        <div class="step">
            <h4>2. Load Distribution</h4>
            <p>
                With 2 nodes, traffic is naturally distributed across multiple physical machines,
                preventing any single node from becoming a bottleneck.
            </p>
        </div>

        <div class="step">
            <h4>3. Rolling Updates Without Downtime</h4>
            <p>
                During deployments, Kubernetes can:
            </p>
            <ol>
                <li>Start new pod on Node 2</li>
                <li>Wait for it to be ready</li>
                <li>Terminate old pod on Node 1</li>
                <li>Start new pod on Node 1</li>
                <li>Terminate old pod on Node 2</li>
            </ol>
            <p><strong>At all times:</strong> At least one pod is serving traffic ‚úÖ</p>
        </div>

        <div class="highlight">
            <strong>üí° Key Takeaway:</strong> Multi-node architecture is not just about redundancy‚Äîit's about
            demonstrating production-ready thinking. In interviews, single-node setups signal "toy project,"
            while multi-node shows understanding of HA, fault tolerance, and enterprise requirements.
        </div>

        <h2 id="setup">‚öôÔ∏è Complete Setup Guide</h2>

        <h3>Prerequisites</h3>
        <div class="code-block"># Required software
            - Java 17 JDK
            - Maven 3.9+
            - Docker 20+
            - kubectl
            - gcloud CLI
            - Git</div>

        <h3>Step 1: Clone Repository</h3>
        <div class="code-block">git clone https://github.com/meyrow/maven-hello-world.git
            cd maven-hello-world</div>

        <h3>Step 2: Build Application</h3>
        <div class="code-block">cd myapp
            mvn clean package -Dmaven.test.skip=true</div>

        <h3>Step 3: Build Docker Image</h3>
        <div class="code-block">docker build -t ilanm/maven-hello-world:1.0.0 .
            docker push ilanm/maven-hello-world:1.0.0</div>

        <h3>Step 4: Create GKE Cluster</h3>
        <div class="code-block">gcloud container clusters create maven-hello-world-cluster \
            --zone=us-central1-a \
            --machine-type=e2-medium \
            --num-nodes=2</div>

        <h3>Step 5: Install ArgoCD</h3>
        <div class="code-block">kubectl create namespace argocd
            kubectl apply -n argocd -f \
            https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

            # Expose ArgoCD UI
            kubectl patch svc argocd-server -n argocd \
            -p '{"spec": {"type": "LoadBalancer"}}'</div>

        <h3>Step 6: Deploy Application</h3>
        <div class="code-block">kubectl apply -f argocd/application.yaml</div>

        <div class="success">
            ‚úÖ <strong>Setup Complete!</strong> Your application is now deployed and managed by GitOps.
        </div>

        <h2 id="deployment">üöÄ Deployment Pipeline</h2>

        <h3>Automated Deployment Flow</h3>
        <ol>
            <li><strong>Developer pushes code</strong> to GitHub repository</li>
            <li><strong>GitHub Actions triggers</strong> CI/CD workflow</li>
            <li><strong>Maven builds</strong> the application JAR</li>
            <li><strong>Docker builds</strong> container image with multi-stage optimization</li>
            <li><strong>Image tagged</strong> with version-gitsha (e.g., 1.0.1-abc123f)</li>
            <li><strong>Image pushed</strong> to Docker Hub registry</li>
            <li><strong>Helm chart updated</strong> with new image tag</li>
            <li><strong>Changes committed</strong> back to Git repository</li>
            <li><strong>ArgoCD detects</strong> Git repository changes</li>
            <li><strong>ArgoCD syncs</strong> cluster state with Git</li>
            <li><strong>Kubernetes pulls</strong> new image from Docker Hub</li>
            <li><strong>Rolling update</strong> deploys new version with zero downtime</li>
        </ol>

        <h2 id="jenkins-comparison">üîÑ Jenkins vs GitOps: CI/CD Comparison</h2>

        <h3>Terminology Mapping</h3>
        <p>
            Coming from Jenkins? Here's how concepts translate to GitHub Actions and GitOps:
        </p>

        <table>
            <tr>
                <th>Jenkins (Groovy)</th>
                <th>GitHub Actions (YAML)</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td><code>pipeline { }</code></td>
                <td><code>workflow</code></td>
                <td>Top-level CI/CD definition</td>
            </tr>
            <tr>
                <td><code>stage('Build')</code></td>
                <td><code>job: build-and-push</code></td>
                <td>Logical grouping of steps</td>
            </tr>
            <tr>
                <td><code>steps { }</code></td>
                <td><code>steps:</code></td>
                <td>Individual commands/actions</td>
            </tr>
            <tr>
                <td><code>agent { }</code></td>
                <td><code>runs-on: ubuntu-latest</code></td>
                <td>Execution environment</td>
            </tr>
        </table>

        <h3>Key Differences</h3>

        <div class="step">
            <h4>1. Execution Model</h4>
            <p><strong>Jenkins:</strong></p>
            <ul>
                <li>Stages run <strong>sequentially</strong> by default</li>
                <li>Use <code>parallel { }</code> for concurrent execution</li>
                <li>Shared workspace between stages</li>
            </ul>

            <p><strong>GitHub Actions:</strong></p>
            <ul>
                <li>Jobs run <strong>in parallel</strong> by default</li>
                <li>Use <code>needs:</code> for sequential execution</li>
                <li>Each job gets fresh VM (no shared workspace)</li>
            </ul>
        </div>

        <div class="step">
            <h4>2. Deployment Approach</h4>
            <p><strong>Jenkins Traditional (Push Model):</strong></p>
            <div class="code-block">stage('Deploy') {
                steps {
                // Jenkins pushes directly to cluster
                sh 'kubectl apply -f k8s/'
                sh 'kubectl rollout status deployment/myapp'
                }
                }</div>
            <p>‚ùå Problems: Jenkins needs cluster credentials, no audit trail, difficult rollbacks</p>

            <p><strong>GitOps (Pull Model):</strong></p>
            <div class="code-block">- name: Update Helm Chart
                run: |
                # CI only updates Git
                sed -i "s|tag:.*|tag: \"$VERSION\"|g" values.yaml
                git commit -am "Update to $VERSION"
                git push

                # ArgoCD (separate system) pulls from Git
                # and applies to cluster automatically</div>
            <p>‚úÖ Benefits: Git is single source of truth, complete audit trail, easy rollbacks, automatic drift detection</p>
        </div>

        <div class="success">
            <strong>üéØ Key Insight:</strong> GitOps separates CI (build/test) from CD (deploy).
            GitHub Actions handles CI, ArgoCD handles CD. This separation improves security,
            auditability, and enables true declarative infrastructure.
        </div>

        <h2 id="gitops">üîÑ GitOps Workflow</h2>

        <h3>GitOps Principles</h3>
        <div class="step">
            <h4>1. Declarative</h4>
            <p>The entire system is described declaratively in Git using Kubernetes manifests and Helm charts.</p>
        </div>

        <div class="step">
            <h4>2. Versioned and Immutable</h4>
            <p>All changes are version-controlled with complete audit history in Git.</p>
        </div>

        <div class="step">
            <h4>3. Pulled Automatically</h4>
            <p>ArgoCD continuously monitors Git and automatically applies changes to the cluster.</p>
        </div>

        <div class="step">
            <h4>4. Continuously Reconciled</h4>
            <p>ArgoCD ensures cluster state matches Git state, auto-healing any drift.</p>
        </div>

        <h2 id="argocd-gitops">üîí Why Direct Edits Are Ignored by ArgoCD</h2>

        <h3>The GitOps Principle: Git as Single Source of Truth</h3>
        <p>
            In GitOps, <strong>Git is the only source of truth</strong> for your cluster state.
            ArgoCD continuously monitors Git and ensures the cluster matches what's declared in Git.
        </p>

        <h3>What Happens When You Edit the Cluster Directly?</h3>

        <div class="highlight">
            <strong>Real Example from Our Setup:</strong><br>
            We tried to expose the application by directly patching the service in Kubernetes:
        </div>

        <div class="code-block"># We ran this command directly on the cluster:
            kubectl patch svc maven-hello-world -n default \
            -p '{"spec": {"type": "LoadBalancer"}}'

            # Output: service/maven-hello-world patched ‚úÖ

            # We checked:
            kubectl get svc maven-hello-world -n default

            # Result:
            NAME                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)
            maven-hello-world   ClusterIP   34.118.228.233   &lt;none&gt;        80/TCP
            ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë
            Still ClusterIP! Why? ü§î</div>

        <h3>What Happened Behind the Scenes</h3>

        <div class="step">
            <h4>1. We Made Direct Change</h4>
            <p>We used <code>kubectl patch</code> to change service type to LoadBalancer.</p>
            <p><strong>Cluster state:</strong> ‚úÖ LoadBalancer (for a few seconds)</p>
        </div>

        <div class="step">
            <h4>2. ArgoCD Detected Drift</h4>
            <p>ArgoCD continuously compares:</p>
            <div class="code-block">Git says:          type: ClusterIP
                Cluster has:       type: LoadBalancer

                Status: OutOfSync (drift detected!) üö®</div>
        </div>

        <div class="step">
            <h4>3. ArgoCD Auto-Healed</h4>
            <p>Because we enabled <strong>Self Heal</strong>, ArgoCD automatically reverted our change:</p>
            <div class="code-block">ArgoCD: "Cluster doesn't match Git. Fixing..."
                kubectl apply -f &lt;manifests-from-git&gt;

                Result: Service changed back to ClusterIP ‚úÖ</div>
        </div>

        <h3>The Correct Way: Update Git First</h3>

        <div class="step">
            <h4>Step 1: Update helm-chart/values.yaml</h4>
            <div class="code-block"># Edit values.yaml in Git
                service:
                type: LoadBalancer  # ‚Üê Changed from ClusterIP
                port: 80
                targetPort: 8080</div>
        </div>

        <div class="step">
            <h4>Step 2: Commit and Push</h4>
            <div class="code-block">git add helm-chart/values.yaml
                git commit -m "feat: expose service via LoadBalancer"
                git push origin master</div>
        </div>

        <div class="step">
            <h4>Step 3: ArgoCD Auto-Syncs</h4>
            <div class="code-block">ArgoCD: "Git changed! Syncing..."
                kubectl apply -f &lt;updated-manifests&gt;

                Result: Service is now LoadBalancer ‚úÖ
                External IP assigned ‚úÖ
                Change persists! ‚úÖ</div>
        </div>

        <div class="success">
            <strong>üí° Remember:</strong> In GitOps, cluster is read-only. All changes go through Git.
            This prevents configuration drift, enables rollbacks, and creates complete audit trails.
        </div>

        <h2 id="monitoring">üìä Monitoring & Operations</h2>

        <h3>Health Endpoints</h3>
        <table>
            <tr>
                <th>Endpoint</th>
                <th>Purpose</th>
                <th>Used By</th>
            </tr>
            <tr>
                <td>/health</td>
                <td>Application health status</td>
                <td>Kubernetes probes, monitoring</td>
            </tr>
            <tr>
                <td>/api/info</td>
                <td>Application metadata</td>
                <td>Observability tools</td>
            </tr>
            <tr>
                <td>/actuator/health</td>
                <td>Spring Boot actuator health</td>
                <td>Advanced monitoring</td>
            </tr>
        </table>

        <h2 id="troubleshooting">üîß Troubleshooting</h2>

        <h3>Common Issues</h3>

        <div class="step">
            <h4>Issue: Pods not starting</h4>
            <div class="code-block"># Check pod status
                kubectl get pods -n default

                # Describe pod
                kubectl describe pod {pod-name} -n default

                # Check logs
                kubectl logs {pod-name} -n default</div>
        </div>

        <div class="step">
            <h4>Issue: ArgoCD not syncing</h4>
            <div class="code-block"># Check ArgoCD application status
                kubectl get application -n argocd

                # Describe application
                kubectl describe application maven-hello-world -n argocd

                # Manual sync
                kubectl patch application maven-hello-world -n argocd \
                --type merge -p '{"operation":{"sync":{}}}'</div>
        </div>

        <h2>üìö Additional Resources</h2>
        <ul>
            <li><a href="https://github.com/meyrow/maven-hello-world" target="_blank">GitHub Repository</a></li>
            <li><a href="https://hub.docker.com/r/ilanm/maven-hello-world" target="_blank">Docker Hub Images</a></li>
            <li><a href="https://argo-cd.readthedocs.io/" target="_blank">ArgoCD Documentation</a></li>
            <li><a href="https://kubernetes.io/docs/" target="_blank">Kubernetes Documentation</a></li>
        </ul>

        <div class="success" style="margin-top: 30px; text-align: center;">
            <h3>üéâ Tutorial Complete!</h3>
            <p>You now have a complete understanding of the platform architecture and operations.</p>
            <a href="/" class="back-link" style="margin-top: 15px;">‚Üê Back to Dashboard</a>
        </div>
    </div>
</div>
</body>
</html>